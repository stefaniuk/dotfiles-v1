#!/bin/bash

# exit if script is sourced
[ -n "$BASH_SOURCE" ] && [ "$(basename -- "$0")" != "dotfiles" ] && exit 1

################################################################################
# variables

DIR=~
USER_NAME=${USER_NAME:-Daniel Stefaniuk}
USER_EMAIL=${USER_EMAIL:-daniel.stefaniuk@gmail.com}
GITHUB_ACCOUNT=${GITHUB_ACCOUNT:-stefaniuk}
BITBUCKET_ACCOUNT=${BITBUCKET_ACCOUNT:-stefaniuk}
GITLAB_ACCOUNT=${GITLAB_ACCOUNT:-stefaniuk}
BASH_PROMPT_SHOW_GIT=${BASH_PROMPT_SHOW_GIT:-true}
REPOSITORY="dotfiles"

program_dir=$(cd "$(dirname "$0" 2> /dev/null)"; pwd)

arg_trace=$(echo "$*" | grep -o -- "--trace"); [ -n "$arg_trace" ] && set -x
arg_update=$(echo "$*" | grep -o -- "--update-os")
arg_install=$(echo "$*" | grep -o -- "--install")
arg_config=$(echo "$*" | grep -o -- "--config")
arg_customise=$(echo "$*" | grep -o -- "--customise")
arg_synchronise_only=$(echo "$*" | grep -o -- "--synchronise-only")
arg_force_download=$(echo "$*" | grep -o -- "--force-download")
arg_directory=$(echo "$*" | grep -Eo -- "--directory=[-_A-Za-z0-9/]+" | sed "s/--directory=//")
arg_user=$(echo "$*" | grep -Eo -- "--user=[-_A-Za-z0-9/]+" | sed "s/--user=//")
arg_minimal=$(echo "$*" | grep -o -- "--minimal")
arg_load_secrets=$(echo "$*" | grep -o -- "--load-secrets")
arg_sudo=$(echo "$*" | grep -o -- "--sudo")
arg_test=$(echo "$*" | grep -o -- "--test")
arg_help=$(echo "$*" | grep -o -- "--help")

arg_install_apps=$(echo "$*" | grep -o -- "--install=[-_,A-Za-z0-9]*" | sed "s/--install=//")
install_already_processed=""
arg_config_apps=$(echo "$*" | grep -o -- "--config=[-_,A-Za-z0-9]*" | sed "s/--config=//")
config_already_processed=""
if [ -z "$arg_config_apps" ] && [ -n "$arg_install_apps" ]; then
    arg_config_apps=$arg_install_apps
fi

################################################################################
# functions

function usage {

    local file=$(basename $0 2> /dev/null)
    echo "
Usage:
    ${file} [options]

Options:
    --update-os
    --install={dependencies|system|admin|developer|user}-bundle|all-bundles,app1,app2,...
    --config[=all,app1,app2,...]
    --customise
    --synchronise-only
    --force-download
    --directory=/dir
    --user=username
    --minimal
    --load-secrets
    --sudo
    --test
    --trace
    --help
"

    exit 0
}

function sudo_keep_alive {

    # update user's time stamp, prompting for password if necessary
    sudo -v
    # keep-alive until script has finished then invalidate sudo session
    while true; do
        sudo -n true
        sleep 1
        if ! kill -0 "$$"; then
            sudo -k
            exit
        fi
    done 2>/dev/null &
}

function dotfiles_download {

    curl -L \
        "https://github.com/${GITHUB_ACCOUNT}/${REPOSITORY}/tarball/master" \
        -o $DIR/$REPOSITORY.tar.gz
    tar -zxf $DIR/$REPOSITORY.tar.gz -C $DIR
    rm -f $DIR/$REPOSITORY.tar.gz
    cp -rf $DIR/$GITHUB_ACCOUNT-$REPOSITORY-*/* $DIR
    rm -rf $DIR/$GITHUB_ACCOUNT-$REPOSITORY-*
    rm -rf $DIR/tmp/*
}

function dotfiles_synchronise {

    printf "Synchronise $REPOSITORY\n\n"

    rsync -rav \
        --include=/ \
        --exclude=/.git* \
        --exclude=.gitkeep \
        --exclude=Dockerfile \
        --exclude=LICENCE \
        --exclude=Makefile \
        --exclude=provision.sh \
        --exclude=README.md \
        --exclude=Vagrantfile \
        $program_dir/* \
        $DIR

    printf "\n"

    # synchronise only
    [ -n "$arg_synchronise_only" ] && exit 0
}

function dotfiles_load_secrets {

    for in_file in $(find $DIR/usr/etc -iname '*.enc' 2> /dev/null); do
        echo $in_file
        out_file=$(mktemp $DIR/tmp/tmp.XXXXXXXX)
        openssl enc -aes-256-cbc -d -a -in $in_file -out $out_file
        trap "rm -f $out_file" EXIT
        source $out_file
    done
}

function dotfiles_setup {

    # set correct permissions
    find $DIR/{bin,etc,lib,sbin,tmp,usr} -type d -exec chmod 700 {} \;
    chmod 555 $DIR/{bin,usr/bin}/*
    chmod 555 $DIR/dotfiles

    # make available custom scripts
    export PATH=$PATH:$DIR/bin:$DIR/usr/bin

    # detect operating system
    source $DIR/lib/resources/bash/.bash_system

    print_h1 "Checking..."
    # check internet connection
    print_h2 "Network connectivity"
    curl --silent --insecure --max-time 10 --retry 3 "https://google.com" > /dev/null
    if [[ $? -ne 0 ]]; then
        print_err "No network"
    fi
    # check operating system
    print_h2 "Operating system"
    if [ $DIST != "macosx" ] && [ $DIST != "ubuntu" ]; then
        print_err "Operating system not supported"
    fi

    # initialise
    (
        print_h1 "Initialising..."
        . $DIR/sbin/include $*
        . $DIR/sbin/initialise $*
    )
    # update
    [ -n "$arg_update" ] && (
        print_h1 "Updating..."
        . $DIR/sbin/include $*
        . $DIR/sbin/update $*
    )
    # install
    [ -n "$arg_install" ] && (
        print_h1 "Installing..."
        . $DIR/sbin/include $*
        dotfiles_install_apps
    )
    # config
    [ -n "$arg_config" ] && (
        print_h1 "Configuring..."
        . $DIR/sbin/include $*
        dotfiles_config_apps
    )
    # customise
    [ -n "$arg_customise" ] && (
        print_h1 "Customising..."
        . $DIR/sbin/include $*
        dotfiles_customise
    )
    # test
    [ -n "$arg_test" ] && /bin/bash -cli "system_test --skip-selected-tests"

    # create dotfiles symlink and copy completion script
    ln -sf $DIR/dotfiles $DIR/usr/bin/dotfiles
    [ -f /etc/bash_completion ] && dir=/etc/bash_completion.d || dir=/usr/local/etc/bash_completion.d
    sudo cp $DIR/lib/resources/dotfiles/dotfiles-completion.bash $dir/dotfiles-completion.bash

    # remove not needed resources
    print_h1 "Cleaning up..."
    rm -rf $DIR/{.gitignore,Dockerfile,LICENCE,Makefile,README.md,Vagrantfile,provision.sh}
    find $DIR/{bin,etc,lib,sbin,tmp,usr} -type f -name '.gitkeep' -exec rm -f {} +
    if [ -n "$arg_minimal" ]; then
        rm -rfv $DIR/{lib,sbin,tmp/*,usr/man,.bash_asserts,.*profile.old}
        find $DIR/{bin,usr/bin}/* -iname '*.test' -exec rm -rfv {} +
    fi

    # set correct ownership
    [ -n "$arg_user" ] && sudo chown -R $arg_user:$arg_user $DIR
}

function dotfiles_install_apps {

    # install requested bundles
    if should_install "dependencies-bundle" || should_install "all-bundles"; then
        run_install dependencies-bundle
    fi
    if should_install "system-bundle" || should_install "all-bundles"; then
        run_install system-bundle
    fi
    if should_install "admin-bundle" || should_install "all-bundles"; then
        run_install admin-bundle
    fi
    if should_install "developer-bundle" || should_install "all-bundles"; then
        run_install developer-bundle
    fi
    if should_install "user-bundle" || should_install "all-bundles"; then
        run_install user-bundle
    fi

    # install requested  applications
    for app in $(find $DIR/lib -maxdepth 1 -type f \( ! -iname "*-bundle" \) -exec basename {} \;); do
        install_app $app
    done
}

function install_app {

    for app in "$@"; do
        should_install $app && run_install $app
    done
}

function should_install {

    # check if already installed at this run
    is_on_list "$install_already_processed" "$1" && return 1

    is_on_list "$arg_install_apps" "$1"
    return $?
}

function run_install {

    for app in "$@"; do
        ([ -f $DIR/lib/$app ] || [ -f $DIR/lib/bundles/$app ]) && (
            # source the requested installation script
            echo $app | grep -q -- "-bundle$" && . $DIR/lib/bundles/$app $* || . $DIR/lib/$app $*
            # check if system specific installation function exists
            local func_sys_spec=
            if type -t "$DIST-install-$app" | grep -q "^function$"; then
                func_sys_spec="$DIST-install-$app"
            fi
            # check if generic installation function exists
            local func_gen=
            if type -t "install-$app" | grep -q "^function$"; then
                func_gen="install-$app"
            fi
            # run the installation functions
            if [ -n "$func_sys_spec" ] || [ -n "$func_gen" ]; then
                echo $app | grep -q -- "-bundle$" && print_h2 $(echo $app | sed 's/-/ /') || print_h3 $app
                [ -n "$func_sys_spec" ] && $func_sys_spec $*
                [ -n "$func_gen" ] && $func_gen $*
            fi
        )
        install_already_processed="$install_already_processed,$app"
    done
}

function dotfiles_config_apps {

    # config requested bundles
    if should_config "dependencies-bundle" || should_config "all-bundles"; then
        run_config dependencies-bundle
    fi
    if should_config "system-bundle" || should_config "all-bundles"; then
        run_config system-bundle
    fi
    if should_config "admin-bundle" || should_config "all-bundles"; then
        run_config admin-bundle
    fi
    if should_config "developer-bundle" || should_config "all-bundles"; then
        run_config developer-bundle
    fi
    if should_config "user-bundle" || should_config "all-bundles"; then
        run_config user-bundle
    fi

    # config requested applications
    for app in $(find $DIR/lib -maxdepth 1 -type f \( ! -iname "*-bundle" \) -exec basename {} \;); do
        config_app $app
    done
}

function config_app {

    for app in "$@"; do
        should_config $app && run_config $app
    done
}

function should_config {

    # check if already configured at this run
    is_on_list "$config_already_processed" "$1" && return 1

    is_on_list "$arg_config_apps" "$1" || is_on_list "$arg_config_apps" "all"
    return $?
}

function run_config {

    for app in "$@"; do
        ([ -f $DIR/lib/$app ] || [ -f $DIR/lib/bundles/$app ]) && (
            # source the requested configuration script
            echo $app | grep -q -- "-bundle$" && . $DIR/lib/bundles/$app $* || . $DIR/lib/$app $*
            # check if system specific configuration function exists
            local func_sys_spec=
            if type -t "$DIST-config-$app" | grep -q "^function$"; then
                func_sys_spec="$DIST-config-$app"
            fi
            # check if generic configuration function exists
            local func_gen=
            if type -t "config-$app" | grep -q "^function$"; then
                func_gen="config-$app"
            fi
            # run the configuration functions
            if [ -n "$func_sys_spec" ] || [ -n "$func_gen" ]; then
                echo $app | grep -q -- "-bundle$" && print_h2 $(echo $app | sed 's/-/ /') || print_h3 $app
                [ -n "$func_sys_spec" ] && $func_sys_spec $*
                [ -n "$func_gen" ] && $func_gen $*
            fi
        )
        config_already_processed="$config_already_processed,$app"
    done
}

function dotfiles_customise {

    for task in $(find $DIR/lib/customisations -maxdepth 1 -type f -exec basename {} \;); do
        run_customise $task
    done
}

function run_customise {

    for task in "$@"; do
        [ -f $DIR/lib/customisations/$task ] && (
            # source the requested customisations script
            . $DIR/lib/customisations/$task $*
            # check if system specific customisations function exists
            local func_sys_spec=
            if type -t "$DIST-customise-$task" | grep -q "^function$"; then
                func_sys_spec="$DIST-customise-$task"
            fi
            # check if generic customisations function exists
            local func_gen=
            if type -t "customise-$task" | grep -q "^function$"; then
                func_gen="customise-$task"
            fi
            # run the customisations functions
            if [ -n "$func_sys_spec" ] || [ -n "$func_gen" ]; then
                print_h3 $task
                [ -n "$func_sys_spec" ] && $func_sys_spec $*
                [ -n "$func_gen" ] && $func_gen $*
            fi
        )
    done
}

function is_on_list {

    local list=$1
    local item=$2

    [ -z "$list" ] && return 1

    echo "$list" | grep "^${item}$" > /dev/null 2>&1 && return 0 # is a
    echo "$list" | grep "^${item}," > /dev/null 2>&1 && return 0 # starts with
    echo "$list" | grep ",${item}$" > /dev/null 2>&1 && return 0 # ends with
    echo "$list" | grep ",${item}," > /dev/null 2>&1 && return 0 # contains

    return 1
}

################################################################################
# main

[ -n "$arg_help" ] && usage
[ -n "$arg_sudo" ] && sudo_keep_alive
[ -n "$arg_directory" ] && DIR=$arg_directory

# use gosu
if ! which sudo > /dev/null 2>&1 && which gosu > /dev/null 2>&1; then
    printf '#!/bin/bash\ngoso root $*\n' > /usr/bin/sudo
    chmod +x /usr/bin/sudo
fi

# use colours in terminal
if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color > /dev/null 2>&1; then
    export TERM="gnome-256color"
elif infocmp xterm-256color > /dev/null 2>&1; then
    export TERM="xterm-256color"
fi

if [ -z "$BASH_SOURCE" ] || [ -n "$arg_force_download" ]; then
    # download from the GitHub repository
    dotfiles_download
elif [[ $program_dir == */projects/$REPOSITORY ]] || [[ $program_dir == */projects/$GITLAB_ACCOUNT/$REPOSITORY ]] || [[ $program_dir == /project ]]; then
    # synchronise with the project content
    dotfiles_synchronise
fi
# decrypt and load secrets
[ -n "$arg_load_secrets" ] && dotfiles_load_secrets
# perform installation and configuration
dotfiles_setup $*

exit 0
