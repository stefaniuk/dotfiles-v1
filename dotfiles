#!/bin/bash

# exit if script is sourced
[ -n "$BASH_SOURCE" ] && [ "$(basename -- "$0")" != "dotfiles" ] && exit 1

################################################################################
# variables

USER_NAME=${USER_NAME:-Daniel Stefaniuk}
USER_EMAIL=${USER_EMAIL:-daniel.stefaniuk@gmail.com}
GITHUB_ACCOUNT=${GITHUB_ACCOUNT:-stefaniuk}
BITBUCKET_ACCOUNT=${BITBUCKET_ACCOUNT:-stefaniuk}
GITLAB_ACCOUNT=${GITLAB_ACCOUNT:-stefaniuk}
BASH_PROMPT_SHOW_GIT=${BASH_PROMPT_SHOW_GIT:-true}

DIR=~
program_dir=$(cd "$(dirname "$0" 2> /dev/null)"; pwd)

arg_debug=$(echo "$*" | grep -o -- "--debug"); [ -n "$arg_debug" ] && set -x
arg_update=$(echo "$*" | grep -o -- "--update-os")
arg_install=$(echo "$*" | grep -o -- "--install")
arg_install_apps=$(echo "$*" | grep -o -- "--install=[-_,A-Za-z0-9]*" | sed "s/--install=//")
arg_config=$(echo "$*" | grep -o -- "--config")
arg_config_apps=$(echo "$*" | grep -o -- "--config=[-_,A-Za-z0-9]*" | sed "s/--config=//")
arg_customise=$(echo "$*" | grep -o -- "--customise")
arg_synchronise_only=$(echo "$*" | grep -o -- "--synchronise-only")
arg_force_download=$(echo "$*" | grep -o -- "--force-download")
arg_directory=$(echo "$*" | grep -Eo -- "--directory=[-_A-Za-z0-9/]+" | sed "s/--directory=//")
arg_user=$(echo "$*" | grep -Eo -- "--user=[-_A-Za-z0-9/]+" | sed "s/--user=//")
arg_load_secrets=$(echo "$*" | grep -o -- "--load-secrets")
arg_extension_man=$(echo "$*" | grep -o -- "--extension-man")
arg_sudo=$(echo "$*" | grep -o -- "--sudo")
arg_test=$(echo "$*" | grep -o -- "--test")
arg_offline=$(echo "$*" | grep -o -- "--offline")
arg_help=$(echo "$*" | grep -o -- "--help")

install_already_processed=""
config_already_processed=""
if [ -z "$arg_config_apps" ] && [ -n "$arg_install_apps" ]; then
    arg_config_apps=$arg_install_apps
fi

################################################################################
# functions

function main {

    [ -n "$arg_help" ] && { usage; exit 0; }
    [ -n "$arg_sudo" ] && sudo_keep_alive
    [ -n "$arg_directory" ] && DIR=$arg_directory

    # back up profile
    [ -f $DIR/.profile ] && [ ! -f $DIR/.profile.old ] && mv -v $DIR/.profile $DIR/.profile.old
    [ -f $DIR/.bash_profile ] && [ ! -f $DIR/.bash_profile.old ] && mv -v $DIR/.bash_profile $DIR/.bash_profile.old

    # use gosu
    if ! which sudo > /dev/null 2>&1 && which gosu > /dev/null 2>&1; then
        printf '#!/bin/bash\ngosu root $*\n' > /usr/bin/sudo
        chmod +x /usr/bin/sudo
    fi

    # use colours in terminal
    if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color > /dev/null 2>&1; then
        export TERM="gnome-256color"
    elif infocmp xterm-256color > /dev/null 2>&1; then
        export TERM="xterm-256color"
    fi

    if [ -z "$BASH_SOURCE" ] || [ -n "$arg_force_download" ]; then
        # download from the GitHub repository
        dotfiles_download
    elif [[ $program_dir == */projects/$GITLAB_ACCOUNT/dotfiles ]] || [[ $program_dir == */projects/dotfiles ]] || [[ $program_dir == /project ]]; then
        # synchronise with the project content
        dotfiles_synchronise
        [ -n "$arg_synchronise_only" ] && exit 0
    fi
    # decrypt and load secrets
    [ -n "$arg_load_secrets" ] && dotfiles_load_secrets
    # perform installation and configuration
    dotfiles_setup $*
}

function sudo_keep_alive {

    # update user's time stamp, prompting for password if necessary
    sudo -v
    # keep-alive until script has finished then invalidate sudo session
    while true; do
        sudo -n true
        sleep 1
        if ! kill -0 "$$"; then
            sudo -k
            exit
        fi
    done 2>/dev/null &
}

function dotfiles_download {

    curl -L \
        "https://github.com/${GITHUB_ACCOUNT}/dotfiles/tarball/master" \
        -o $DIR/dotfiles.tar.gz
    tar -zxf $DIR/dotfiles.tar.gz -C $DIR
    cp -rf $DIR/$GITHUB_ACCOUNT-dotfiles-*/{.bash,}* $DIR

    if [ -n "$arg_extension_man" ]; then
        curl -L \
            "https://github.com/${GITHUB_ACCOUNT}/dotfiles-man/tarball/master" \
            -o $DIR/dotfiles-man.tar.gz
        tar -zxf $DIR/dotfiles-man.tar.gz -C $DIR
        cp -rf $DIR/$GITHUB_ACCOUNT-dotfiles-man*/* $DIR
    fi

    rm -rf $DIR/$GITHUB_ACCOUNT-dotfiles*
    rm -f $DIR/dotfiles*.tar.gz
    rm -rf $DIR/tmp/*
}

function dotfiles_synchronise {

    print_h3 "\nSynchronise dotfiles\n"
    rsync -rav \
        --include=/ \
        --exclude=/.git* \
        --exclude=.gitignore \
        --exclude=.gitkeep \
        --exclude=Dockerfile \
        --exclude=LICENCE \
        --exclude=Makefile \
        --exclude=provision.sh \
        --exclude=README.md \
        --exclude=Vagrantfile \
        $program_dir/{.bash,}* \
        $DIR \
    | grep -Ev "/$"

    if [ -n "$arg_extension_man" ] && [ -d $program_dir-man ]; then
        print_h3 "\nSynchronise dotfiles-man\n"
        rsync -rav \
            --include=/ \
            --exclude=/.git* \
            --exclude=.gitignore \
            --exclude=.gitkeep \
            --exclude=LICENCE \
            --exclude=README.md \
            $program_dir-man/* \
            $DIR \
        | grep -Ev "/$"
        printf "\n"
    fi
}

function dotfiles_load_secrets {

    for in_file in $(find $DIR/usr/etc -iname '*.enc' 2> /dev/null); do
        echo $in_file
        out_file=$(mktemp $DIR/tmp/tmp.XXXXXXXX)
        openssl enc -aes-256-cbc -d -a -in $in_file -out $out_file
        trap "rm -f $out_file" EXIT
        source $out_file
    done
}

function dotfiles_setup {

    # make available custom scripts
    export PATH=$PATH:$DIR/bin:$DIR/usr/bin

    # detect operating system
    source $DIR/.bash_system

    print_h1 "Checking..."
    # check internet connection
    print_h2 "Network connectivity"
    curl --silent --insecure --max-time 10 --retry 3 "https://google.com" > /dev/null
    if [[ $? -ne 0 ]]; then
        $arg_offline=true
        print_err "No network"
    fi
    # check operating system
    print_h2 "Operating system"
    if [ $DIST != "macosx" ] && [ $DIST != "ubuntu" ]; then
        print_err "Operating system not supported"
    fi

    os_common
    os_initialise
    [ -n "$arg_update" ]    && ( os_update )
    [ -n "$arg_install" ]   && ( os_install_apps )
    [ -n "$arg_config" ]    && ( os_config_apps )
    [ -n "$arg_customise" ] && ( os_customise )
    [ -n "$arg_test" ]      && ( os_test )
    dotfiles_bash

    # copy dotfiles completion script
    [ -f /etc/bash_completion ] && dir=/etc/bash_completion.d || dir=/usr/local/etc/bash_completion.d
    sudo cp $DIR/lib/resources/dotfiles/dotfiles-completion.bash $dir/dotfiles-completion.bash

    # cleanup
    rm $DIR/{LICENCE,README.md}

    # set correct ownership
    [ -n "$arg_user" ] && sudo chown -R $arg_user:$arg_user $DIR
}

function dotfiles_bash {

    if [ $DIST = "macosx" ]; then
        [ -z "$arg_offline" ] && $brew_install bash
        if [ -f $(brew --prefix)/bin/bash ]; then
            sudo -E file_remove_str "\n$(brew --prefix)/bin/bash" /private/etc/shells --multiline
            sudo bash -c "echo $(brew --prefix)/bin/bash >> /private/etc/shells"
            sudo chsh -s $(brew --prefix)/bin/bash $USER 2> /dev/null
        fi
    fi
    file_replace_str "USER_NAME=\"unknown\"" "USER_NAME=\"$USER_NAME\"" $DIR/.bash_exports
    file_replace_str "USER_EMAIL=\"unknown\"" "USER_EMAIL=\"$USER_EMAIL\"" $DIR/.bash_exports
    file_replace_str "GITHUB_ACCOUNT=\"unknown\"" "GITHUB_ACCOUNT=\"$GITHUB_ACCOUNT\"" $DIR/.bash_exports
    file_replace_str "BITBUCKET_ACCOUNT=\"unknown\"" "BITBUCKET_ACCOUNT=\"$BITBUCKET_ACCOUNT\"" $DIR/.bash_exports
    file_replace_str "GITLAB_ACCOUNT=\"unknown\"" "GITLAB_ACCOUNT=\"$GITLAB_ACCOUNT\"" $DIR/.bash_exports
    file_replace_str "BASH_PROMPT_SHOW_GIT=\"true\"" "BASH_PROMPT_SHOW_GIT=\"$BASH_PROMPT_SHOW_GIT\"" $DIR/.bash_exports
}

function os_common {

    if [ $DIST = "macosx" ]; then
        brew_update="brew update --verbose"
        brew_upgrade="brew upgrade --verbose"
        brew_tap="brew tap"
        brew_install="brew install --force --verbose"
        cask_install="brew cask install --force --verbose"
        mas_upgrade="mas upgrade"
        mas_install="mas install"
        if ! which brew > /dev/null; then
            #softwareupdate --install -all
            if ! xcode-select -p | grep '/Applications/Xcode.app/Contents/Developer' > /dev/null; then
                xcode-select --install
                sudo xcodebuild -license accept
            fi
            ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
            $brew_tap caskroom/cask
            $brew_tap caskroom/versions
        fi
        if ! which mas > /dev/null; then
            $brew_install mas # SEE: https://github.com/mas-cli/mas
            $mas_upgrade
        fi
    fi
    if [ $DIST = "ubuntu" ]; then
        DEBIAN_FRONTEND=noninteractive
        apt_get_update="sudo apt-get --yes update"
        apt_get_upgrade="sudo apt-get --yes upgrade"
        apt_get_install="sudo apt-get --yes --ignore-missing --no-install-recommends install"
        apt_add_repository="sudo add-apt-repository --yes"
    fi
}

function os_initialise {

    if [ $DIST = "ubuntu" ]; then
        if [ -f /etc/sudoers ] && ( sudo cat /etc/sudoers | grep "env_reset" > /dev/null || sudo cat /etc/sudoers | grep "secure_path" > /dev/null ); then
            sudo $DIR/bin/file_remove_str "Defaults[[:space:]]+env_reset" /etc/sudoers
            sudo $DIR/bin/file_remove_str "Defaults[[:space:]]+secure_path=\".*\"" /etc/sudoers
        fi
    fi
}

function os_update {

    print_h1 "Updating..."

    if [ $DIST = "macosx" ]; then
        print_h2 "System packages"
        $mas_upgrade
        print_h2 "Homebrew metadata"
        $brew_update
        print_h2 "Homebrew packages"
        $brew_upgrade
    fi
    if [ $DIST = "ubuntu" ]; then
        print_h2 "System metadata"
        $apt_get_update
        print_h2 "System packages"
        $apt_get_upgrade
    fi
}

function os_install_apps {

    print_h1 "Installing..."

    # install requested bundles
    if should_install "dependencies-bundle" || should_install "all-bundles"; then
        run_install dependencies-bundle
    fi
    if should_install "system-bundle" || should_install "all-bundles"; then
        run_install system-bundle
    fi
    if should_install "admin-bundle" || should_install "all-bundles"; then
        run_install admin-bundle
    fi
    if should_install "developer-bundle" || should_install "all-bundles"; then
        run_install developer-bundle
    fi
    if should_install "user-bundle" || should_install "all-bundles"; then
        run_install user-bundle
    fi

    # install requested  applications
    for app in $(find $DIR/lib -maxdepth 1 -type f \( ! -iname "*-bundle" \) -exec basename {} \;); do
        install_app $app
    done
}

function os_config_apps {

    print_h1 "Configuring..."

    # config requested bundles
    if should_config "dependencies-bundle" || should_config "all-bundles"; then
        run_config dependencies-bundle
    fi
    if should_config "system-bundle" || should_config "all-bundles"; then
        run_config system-bundle
    fi
    if should_config "admin-bundle" || should_config "all-bundles"; then
        run_config admin-bundle
    fi
    if should_config "developer-bundle" || should_config "all-bundles"; then
        run_config developer-bundle
    fi
    if should_config "user-bundle" || should_config "all-bundles"; then
        run_config user-bundle
    fi

    # config requested applications
    for app in $(find $DIR/lib -maxdepth 1 -type f \( ! -iname "*-bundle" \) -exec basename {} \;); do
        config_app $app
    done
}

function os_customise {

    print_h1 "Customising..."

    for task in $(find $DIR/lib/customisations -maxdepth 1 -type f -exec basename {} \;); do
        run_customise $task
    done
}

function os_test {

    /bin/bash -cli "system_test --skip-selected-tests"
}

function install_app {

    for app in "$@"; do
        should_install $app && run_install $app
    done
}

function should_install {

    # check if already installed at this run
    _is_on_list "$install_already_processed" "$1" && return 1

    _is_on_list "$arg_install_apps" "$1"
    return $?
}

function run_install {

    for app in "$@"; do
        ([ -f $DIR/lib/$app ] || [ -f $DIR/lib/bundles/$app ]) && (
            # source the requested installation script
            echo $app | grep -q -- "-bundle$" && . $DIR/lib/bundles/$app $* || . $DIR/lib/$app $*
            # check if system specific installation function exists
            local func_sys_spec=
            if type -t "$DIST-install-$app" | grep -q "^function$"; then
                func_sys_spec="$DIST-install-$app"
            fi
            # check if generic installation function exists
            local func_gen=
            if type -t "install-$app" | grep -q "^function$"; then
                func_gen="install-$app"
            fi
            # run the installation functions
            if [ -n "$func_sys_spec" ] || [ -n "$func_gen" ]; then
                echo $app | grep -q -- "-bundle$" && print_h2 $(echo $app | sed 's/-/ /') || print_h3 $app
                [ -n "$func_sys_spec" ] && $func_sys_spec $*
                [ -n "$func_gen" ] && $func_gen $*
            fi
        )
        install_already_processed="$install_already_processed,$app"
    done
}

function config_app {

    for app in "$@"; do
        should_config $app && run_config $app
    done
}

function should_config {

    # check if already configured at this run
    _is_on_list "$config_already_processed" "$1" && return 1

    _is_on_list "$arg_config_apps" "$1" || _is_on_list "$arg_config_apps" "all"
    return $?
}

function run_config {

    for app in "$@"; do
        ([ -f $DIR/lib/$app ] || [ -f $DIR/lib/bundles/$app ]) && (
            # source the requested configuration script
            echo $app | grep -q -- "-bundle$" && . $DIR/lib/bundles/$app $* || . $DIR/lib/$app $*
            # check if system specific configuration function exists
            local func_sys_spec=
            if type -t "$DIST-config-$app" | grep -q "^function$"; then
                func_sys_spec="$DIST-config-$app"
            fi
            # check if generic configuration function exists
            local func_gen=
            if type -t "config-$app" | grep -q "^function$"; then
                func_gen="config-$app"
            fi
            # run the configuration functions
            if [ -n "$func_sys_spec" ] || [ -n "$func_gen" ]; then
                echo $app | grep -q -- "-bundle$" && print_h2 $(echo $app | sed 's/-/ /') || print_h3 $app
                [ -n "$func_sys_spec" ] && $func_sys_spec $*
                [ -n "$func_gen" ] && $func_gen $*
            fi
        )
        config_already_processed="$config_already_processed,$app"
    done
}

function run_customise {

    for task in "$@"; do
        [ -f $DIR/lib/customisations/$task ] && (
            # source the requested customisations script
            . $DIR/lib/customisations/$task $*
            # check if system specific customisations function exists
            local func_sys_spec=
            if type -t "$DIST-customise-$task" | grep -q "^function$"; then
                func_sys_spec="$DIST-customise-$task"
            fi
            # check if generic customisations function exists
            local func_gen=
            if type -t "customise-$task" | grep -q "^function$"; then
                func_gen="customise-$task"
            fi
            # run the customisations functions
            if [ -n "$func_sys_spec" ] || [ -n "$func_gen" ]; then
                print_h3 $task
                [ -n "$func_sys_spec" ] && $func_sys_spec $*
                [ -n "$func_gen" ] && $func_gen $*
            fi
        )
    done
}

function _is_on_list {

    local list=$1
    local item=$2

    [ -z "$list" ] && return 1

    echo "$list" | grep "^${item}$" > /dev/null 2>&1 && return 0 # is a
    echo "$list" | grep "^${item}," > /dev/null 2>&1 && return 0 # starts with
    echo "$list" | grep ",${item}$" > /dev/null 2>&1 && return 0 # ends with
    echo "$list" | grep ",${item}," > /dev/null 2>&1 && return 0 # contains

    return 1
}

function usage {

    local file=$(basename $0 2> /dev/null)
    printf "\nUsage: ${file} [options]\n"
    printf "\nOptions:\n"
    printf "\t--update-os\n"
    printf "\t--install={dependencies|system|admin|developer|user}-bundle|all-bundles,app1,app2,...\n"
    printf "\t--config[=all,app1,app2,...]\n"
    printf "\t--customise\n"
    printf "\t--synchronise-only\n"
    printf "\t--force-download\n"
    printf "\t--directory=/dir\n"
    printf "\t--user=username\n"
    printf "\t--minimal\n"
    printf "\t--load-secrets\n"
    printf "\t--extension-man\n"
    printf "\t--sudo\n"
    printf "\t--test\n"
    printf "\t--debug\n"
    printf "\t--offline\n"
    printf "\t--help\n"
    printf "\n"
}

main $*

exit 0
